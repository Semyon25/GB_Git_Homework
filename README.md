# Что такое Git
**Git** — распределённая система управления версиями. Проект был создан Линусом Торвальдсом для управления разработкой ядра Linux, первая версия выпущена 7 апреля 2005 года. На сегодняшний день его поддерживает Джунио Хамано.

# Подготовка репозитория
**Репозиторий Git** — это виртуальное хранилище проекта. В нем можно хранить версии кода для доступа по мере необходимости.

**Инициализация нового репозитория:** *git init*
Для создания нового репозитория используется команда *git init*. Команду *git init* выполняют только один раз для первоначальной настройки нового репозитория. Выполнение команды приведет к созданию нового подкаталога .git в вашем рабочем каталоге. Кроме того, будет создана новая главная ветка.

# Создание "сохранений"
## Команда git commit
Команда git commit делает для проекта снимок текущего состояния изменений, добавленных в раздел проиндексированных файлов. Такие подтвержденные снимки состояния можно рассматривать как «безопасные» версии проекта — Git не будет их менять, пока вы явным образом не попросите об этом. Перед выполнением команды git commit необходимо использовать команду git add, чтобы добавить в проект («проиндексировать») изменения, которые будут сохранены в коммите. Эти две команды, git commit и git add, используются чаще всего.

Можно создать коммит одно командой, но только для отслеживаемых файлов. В данном случае в индекс добавляются все изменения файлов, но только тех файлов, которые уже когда-либо были добавлены в Git репозиторий — отслеживаемые файлы (Tracked files). То есть новые неотслеживаемые файлы (Untracked files) данной командой игнорируются.

>git commit -a -m "Commit message."

# Переключение между сохранениями
## Как переместится к определенному коммиту
Чтобы перейти к определенному коммиту, используйте ту же команду *git checkout*, но вместо имени ветки передайте ей SHA коммита.

Ветки по сути являются просто указателями трекерами отдельных коммитов в истории Git.

Как найти SHA коммита
Один из способов найти SHA коммита — просмотреть лог Git. Делается это при помощи команды *git log*

В первой строке каждого коммита после слова commit есть длинная строка букв и цифр: 94ab1fe28727…

Вот она и называется SHA. Это уникальный идентификатор, генерируемый для каждого коммита.

Чтобы перейти к определенному коммиту, вам нужно лишь передать его SHA в качестве параметра команды *git checkout*

__Примечание:__ обычно можно использовать всего несколько первых символов SHA, потому что первые 4-5 символов скорее всего образуют уникальную комбинацию в рамках проекта.

# Журнал изменений
## Как создать журнал изменений (простой способ)
При использовании этого способа вам не потребуется никакой предварительной подготовки. Все, что вам нужно, — это ввести несколько команд в своем Git-репозитории.

В качестве простого напоминания: когда вы набираете команду «git log», отображается список всех ваших коммитов.

Эта команда может принимать несколько параметров. Мы используем их, чтобы изменить вывод и получить его усовершенствованный вариант для создания журнала изменений.

Набрав следующую команду, вы получите вывод, в котором каждый коммит будет находиться на отдельной строке.

### Теперь давайте посмотрим, что можно сделать с помощью следующей команды:
>git log --pretty="%s"

С ее помощью вы можете вывести список коммитов в нужном вам стиле.

«%s» здесь соответствует непосредственно заголовку коммита. Вы можете изменить строку, чтобы стиль отображения коммитов был таким, как вам нравится.

В нашем случае мы хотим создать список
>git log --pretty="- %s"

Мы сделали это! Мы создали простейший журнал изменений!

**Примечание:** если вы хотите продвинуться дальше и сохранять свой список изменений быстрее, то вместо копирования и вставки результата в файл, перенаправьте его в терминал, набрав: git log — pretty=” — %s “ > changelog.md.

# Ветки в Git
Ветка в Git это подвижный указатель на один из коммитов. Обычно ветка указывает на последний коммит в цепочке коммитов. Ветка берет свое начало от какого-то одного коммита.

Сделать новую ветку и переключиться на нее можно выполнив команды:

>git checkout –b <имя новой ветки> 

Просто сделать ветку, не переключаясь на нее можно командой

>git branch <имя ветки>

переключиться на ветку

>git checkout <имя ветки>

Важно понимать, что ветка берет свое начало не от ветки, а от последнего коммита который находиться в той ветке, в которой вы находились.

# Слияние веток и решение конфликтов
Ветка обычно заканчивается специальным merge коммитом, который говорит, что ветку нужно объединить с какой-то другой веткой. В merge коммите содержатся две ссылки на два коммита которые объединяются в одну ветку.

Существует другая ситуация при объединении веток, в которой merge может произойти без merge commit. Дело в том, что если в одной из веток не произошло никаких изменений, то необходимость в merge commit с двумя предками отпадает. В таком случае, при слиянии веток, Git просто сделает пометку о том, что дальше будут идти коммиты той ветки с которой эта ветка была объединена. Такая схема merge называется слияние-перемотка (fast-forward merge).

Во всех этих случаях, после того, как ветка объединяется с другой веткой, все коммиты сделанные в ней, попадают в ветку с которой она была объединена. Так же важно понимать, что merge это не двунаправленная операция. Если смержить ветку задачи в мастер ветку, то в мастер ветке появится код, который находился в ветке задачи, а в ветке задачи не появиться новый код из мастер ветки. Если нужно что бы это произошло, нужно смержить мастер ветку в ветку задачи.
Что бы смержить одну ветку в другую нужно вначале переключиться на ту ветку, в которую вы хотите смержить.

Затем выполнить команду
>git merge <имя ветки>

Так выглядит работа с ветками в общих чертах.

Обратите внимание на то, что перед тем как заводить новую ветку нужно выполнить git pull. Делается это по нескольким причинам.

* Другой программист мог изменить код, в том числе внести такие изменения, которые повлияют на решение задачи, для которой вы заводите новую ветку. Эти изменения могут вам пригодиться при решении своей задачи.
* Из-за этих изменений вы можете получить конфликт при мерже.
* Больше шанс что у вас получится merge commit. Это не так плохо, как два предыдущих пункта. Но если можно избежать лишнего коммита, то почему бы этого не сделать?

## Создание конфликта слияния
Чтобы лучше разобраться в конфликтах слияния, в следующем разделе мы смоделируем конфликт для дальнейшего изучения и разрешения. Для запуска моделируемого примера будет использоваться интерфейс Git c Unix-подобной командной строкой.

С помощью приведенной в этом примере последовательности команд выполняются следующие действия.

* Создается новый каталог с именем git-merge-test, выполняется переход в этот каталог и инициализация его как нового репозитория Git.
* Создается новый текстовый файл merge.txt с некоторым содержимым.
* В репозиторий добавляется файл merge.txt и выполняется коммит.

Теперь у нас есть новый репозиторий с одной веткой main и непустым файлом merge.txt. Далее создадим новую ветку, которая будет использоваться как конфликтующая при слиянии.

Представленная выше последовательность команд выполняет следующие действия.

* Создает новую ветку с именем new_branch_to_merge_later и выполняет переход в нее.
* Перезаписывает содержимое файла merge.txt.
* Выполняет коммит нового содержимого. 

В этой новой ветке new_branch_to_merge_later мы создали коммит, который переопределил содержимое файла merge.txt.

Эта последовательность команд выполняет переключение на ветку main, добавляет содержимое в файл merge.txt и делает коммит. После этого в нашем экспериментальном репозитории находятся два новых коммита, первый — в ветке main, а второй — в ветке new_branch_to_merge_later. Теперь запустим команду git merge new_branch_to_merge_later и посмотрим, что из этого выйдет!

БАХ! 💥 Возник конфликт. Хорошо, что система Git сообщила нам об этом.

### Выявление конфликтов слияния
Как мы убедились на выполняемом примере, Git выводит небольшое описательное сообщение о возникновении КОНФЛИКТА. Чтобы получить более глубокое понимание проблемы, можно запустить команду git status.

Вывод команды git status говорит о том, что из-за конфликта не удалось слить пути. Теперь файл merge.text отображается как измененный. Давайте изучим этот файл и посмотрим, что изменилось.

Для просмотра содержимого файла merge.txt воспользуемся командой cat. Видно, что в файле появились новые странные дополнения:

Эти новые строки можно рассматривать как «разделители конфликта». Строка ======= является «центром» конфликта. Все содержимое между этим центром и строкой <<<<<<< HEAD находится в текущей ветке main, на которую ссылается указатель HEAD. А все содержимое между центром и строкой >>>>>>> new_branch_to_merge_later является содержимым ветки для слияния.

Самый простой способ разрешить конфликт — отредактировать конфликтующий файл. Откройте файл merge.txt в привычном редакторе. В нашем примере просто удалим все разделители конфликта. 

После редактирования файла выполните команду git add merge.txt, чтобы добавить новое объединенное содержимое в раздел проиндексированных файлов. Для завершения слияния создайте новый коммит.

Git обнаружит, что конфликт разрешен, и создаст новый коммит слияния для завершения процедуры слияния.


# Удаление веток

## Как удалить локальную ветку в Git
Локальные ветки – это ветки на вашем компьютере, которые не влияют на ветки удаленного репозитория.

Команда для удаления локальной ветки в Git:
* git branch – команда для удаления локальной ветки.
* -d – флаг, опция команды git branch, сокращенный вариант записи --delete. Как и следует из названия, предназначен для удаления ветки.
* local_branch_name – имя удаляемой ветки.

# Работа с удаленными репозиториями

## 1. Как подключится к удаленному репозиторию

Для загрузки данных в удаленный репозитарию сначала нужно к нему подключиться. В нашем примере мы используем адрес https://github.com/tutorialzine/awesome-project, однако пользователь может создать собственный удаленный репозитарий на GitHub, BitBucket или другом подобном сервисе. Это занимает некоторое время, однако в дальнейшем полностью себя оправдывает, тем более, что подобные службы имеют пошаговые инструкции для правильно выполнения нужных действий.

Для того, чтобы связать созданный нами локальный репозитарий с удаленным, выполним такую команду:

### This is only an example. Replace the URI with your own repository address.
> $ git remote add origin https://github.com/tutorialzine/awesome-project.git  

Первая строка напоминает нам, что URI репозитария, который приведен в примере, нужно изменить на свой.

Иногда бывает так, что проект имеет несколько удаленных репозитариев – в таком случае каждому из них присваивается собственное имя. Главный репозитарий принято называть origin.

## 2. Как отправить изменения в удаленный репозитарий?

Теперь, когда у нас в локальном репозитарии создан коммит и мы подключились к удаленному, можем отправить его на сервер. Мы это будем делать каждый раз, когда хотим обновить данные в удаленном репозитарии.

Отправка коммита осуществляется с помощью команды push, которая имеет два параметра - имя удаленного репозитория (в нашем случае origin) и ветку, в которую необходимо внести изменения (master — это ветка по умолчанию для всех репозиториев).

> $ git push origin master
Counting objects: 3, done.
Writing objects: 100% (3/3), 212 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://github.com/tutorialzine/awesome-project.git  
[new branch] master -> master  

Если мы все сделали правильно, то отправленный файл hello.txt на удаленном сервере мы можем увидеть с помощью браузера. Важный момент – некоторые сервисы для отправки изменений могут требовать дополнительной аутентификации.

## 3. Как клонировать удаленный репозиторий?

Если у других пользователей возникла необходимость клонировать удаленный репозитарий, они могут получить полностью работоспособную копию при помощи команды clone:

> $ git clone https://github.com/tutorialzine/awesome-project.git  

GitHub автоматически создаст новый локальный репозитарий в виде удаленного на собственном сервере.

## 4. Как запросить изменения с удаленного репозитария?

В случае, если другим пользователям нет необходимости делать клон удаленного репозитария, а нужно просто получить информацию об изменениях, это можно сделать с помощью команды pull:

> $ git pull origin master
From https://github.com/tutorialzine/awesome-project  
branch master -> FETCH_HEAD  
Already up-to-date.

Она скачивает новые изменения. Так как мы ничего нового не вносили с тех пор, как клонировали проект, изменений, доступных к скачиванию, нет.